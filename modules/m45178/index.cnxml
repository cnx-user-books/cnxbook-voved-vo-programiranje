<document xmlns="http://cnx.rice.edu/cnxml">
  <title>Константи и оператори</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m45178</md:content-id>
  <md:title>Константи и оператори</md:title>
  <md:abstract/>
  <md:uuid>5144c002-124e-4420-8896-2658ed603b74</md:uuid>
</metadata>

<content>
    <section id="import-auto-id1172362969360">
      <title>Kонстанти</title>
      <para id="import-auto-id1172363258009">Терминот константа значи дека истата не се менува за време на работата на програмата. Секоја променлива се декларира дека припаѓа на одреден тип податоци. Овој тип ја дефинира големината на променливата и како истата може да се користи. Слично, кога се специфицира константа, се дава и типот на константата. Кај променливите типот е очигледен со нивната декларација. Константите меѓутоа не се декларираат. Одредувањето на нивниот тип не е толку едноставно.</para>
      <para id="import-auto-id1172361996376">Постојат повеќе типови константи во С:</para>
      <list id="import-auto-id1172362183019" list-type="bulleted">
        <item> Броевите кои содржат „<emphasis effect="bold">.</emphasis>“ или „<emphasis effect="bold">е</emphasis>“ се <emphasis effect="bold">double</emphasis>: 3.5, 1е-7, -1.29е15</item>
        <item> За наместо double да се користат <emphasis effect="bold">float </emphasis>константи на крајот се додава „F“: 3.5F, 1e-7F</item>
        <item> За <emphasis effect="bold">long double</emphasis> константи се додава „<emphasis effect="bold">L</emphasis>“: 1.29е15L, 1e-7L</item>
        <item> Броевите без „<emphasis effect="bold">.</emphasis>“, „<emphasis effect="bold">е</emphasis>“ или „<emphasis effect="bold">F</emphasis>“ се <emphasis effect="bold">int</emphasis>: 1000, -35</item>
        <item> За <emphasis effect="bold">long int</emphasis> константи се додава „<emphasis effect="bold">L</emphasis>“: 9000000L.</item>
      </list>
      <para id="import-auto-id1172356261569">Именуваните константи може да се креираат со користење на резервираниот збор <emphasis effect="bold">const</emphasis>. Со користење на const типот на константата експлицитно се дефинира. По креирањето на константата, таа може да се јави само од десната страна на операторот за доделување вредност.</para>
      <example id="eip-239"><code id="eip-844" display="block">#include &lt;stdio.h&gt;
main()
{
    const long double pi = 3.141592653590L;
    const int denovi_vo_nedela = 7;
    const nedela = 0; // po default int
    denovi_vo_nedela = 5; // greska
}
</code></example><para id="import-auto-id1172360945083">Именуваните константи може да се креираат и со користење на предпроцесорот и за нив по правило се користат големи букви.</para>
      <example id="eip-755"><code id="eip-349" display="block">#include &lt;stdio.h&gt;

#define PI 3.141592653590L
#define DENOVI_VO_NEDELA 7
#define NEDELA 7
main()
{
    long broj = PI;
    int den = NEDELA;
}

</code></example><para id="import-auto-id1172364671521">Бидејќи предпроцесорот е едитор тој ја изведува операцијата најди и замени. За да се влезе во овој начин на работа се користи наредбата <emphasis effect="bold"><emphasis effect="italics">#</emphasis></emphasis><emphasis effect="bold">define</emphasis>. Нејзината синтакса е всушност:</para>
      <para id="import-auto-id1172364713981"><emphasis effect="bold">#define tekst_za_baranje tekst_za_zamena</emphasis></para><para id="import-auto-id1172364707464">Се заменуваат само цели зборови. Низи од знаци во наводници се игнорираат.</para>
      <section id="import-auto-id1172363298717">
        <title>Оператори</title>
        <para id="import-auto-id1172361749608">Постојат повеќе групи на оператори и тоа:</para>
        <list id="import-auto-id1172361880792" list-type="bulleted">
          <item>Аритметички оператори (+, -, *, /, % (не работи со реални броеви))</item>
          <item>Релациони оператори (&gt;, &lt;, &gt;=, &lt;=, = =, !=) </item>
          <item>Логички оператори (&amp;&amp;, ||)</item>
          <item>Оператори за инкрементирање и декрементирање (++, --)</item>
        </list>
        <para id="import-auto-id1172364760143">Аритметичките оператори се користат за претставување на математички изрази. При тоа, + и – може да се користат и на унарен начин:</para>
        <code id="eip-843" display="block">x = + y;</code><code id="eip-11" display="block">x = - y;</code><para id="import-auto-id1172362944366">Првата наредба е иста со x=y, додека втората ја множи вредноста на y со -1, а потоа ја доделува на x.</para>
        <section id="import-auto-id1172361018855">
          <title>Реални броеви наспроти целобројни вредности</title>
          <para id="import-auto-id1172364607057">Операторот за делење е специјален. Постои голема разлика меѓу делењето на целобројни и реални вредности. Ако станува збор за целобројно делење, резултатот е само целиот дел од делењето. Така на пример, 19/10 е 1. Ова значи дека делењето се извршува на различни начини во зависност од контекстот во кој се наоѓа, односно во зависност од типот на операндите со кои ќе работи. Така, ако <emphasis effect="bold">двата </emphasis>операнди се цели броеви ќе се изврши целобројно делење.</para>
          <para id="import-auto-id1172364725801">Ако барем деленикот или делителот е реален број, тогаш се извршува делење на реални броеви и резултатот од ова делење е реален број. Така 19.0/10.0 е 1.9 (резултатот е исти и за 19/10.0 и 19.0/10).</para>
          <example id="eip-535"><code id="eip-493" display="block">int main(void)
{
    int i = 5, j = 4, k;
    double f = 5.0, g = 4.0, h;

    k = i / j;  // celobrojno delenje na dva int vrednosti
    h = f / g;  // realno delenje rezultat 1.25
    h = i / j;  // celobrojno delenje iako h e realen, rezultatot e 1.000

    return 0;
}</code></example><para id="import-auto-id1172361975529">Програмскиот јазик С користи различни аритметички оператори и различни типови на операнди така што операторот ќе одбере каков вид на операција ќе изведе. При тоа комапјлерот се грижи само за типот на операндите. При изведувањето на операцијата не се зема во предвид типот на променливата на која и се доделува резултатот. </para>
        </section>
        <section id="import-auto-id1172364327090">
          <title>Оператори за инкрементирање и декрементирање</title>
          <para id="import-auto-id1172361858212">Операторот за инкрементирање (++) го зголемува операндот за еден, додека операторот за декрементирање (--) го намалува операндот за еден. Операндот кој се користи со овие оператори мора да биде една променлива и затоа овие оператори се нарекуваат унарни.</para>
          <para id="import-auto-id1172364797552">Така, ако на целобројната променлива i и е доделена вредноста 5, изразот ++i ја зголемува вредноста на i за еден, со што i станува 6, додека изразот --i  ја намалува вредноста на i за еден и i станува 4. </para><para id="import-auto-id1172363221794">Операторите за инкрементирање и декрементирање може да се користат на два различни начини, зависно од тоа дали операторот е запишан пред или по операндот.</para>
          <list id="import-auto-id1172362926990" list-type="enumerated" number-style="arabic">
            <item>Ако операторот е пред операндот (++i), тогаш операндот ќе ја промени својата вредност пред да се искористи во понатамошниот тек на наредбата.</item>
            <item>Ако пак операторот е после операндот (i++), тогаш вредноста на операндот се менува откако истата е искористена.  </item>
          </list>
          <example id="eip-531"><code id="eip-207" display="block">i = 1; 
printf(“ i = %d\n”, i);//i=1
printf(” i = %d\n”, ++i);//i=2
printf(” i = %d\n”, i);//i=2
printf(” i = %d\n”, i++);//i=2
printf(” i = %d\n”, i);//i=3</code></example></section>
        <section id="import-auto-id1172362926474">
          <title>Релациони и логички оператори</title>
          <para id="import-auto-id1172361882901">Треба да се води сметка дека нема boolean (булов) тип на податок во С, наместо него се користи целобројниот int тип. При тоа, вредноста 0 е неточно, додека секоја друга вредност е точно.</para>
          <para id="import-auto-id1172364785807">Резултатот на логичката И операција (оператор &amp;&amp;) ќе биде точно само ако двата операнди се точни, додека резултатот на логичката операција ИЛИ (оператор ||) ќе биде точно ако било кој од операндите или, пак, двата операнди се точни. Со други зборови, резултатот од логичката операција ИЛИ ќе биде неточно, само ако двата операнди се неточни. Резултатот од логичката операција НЕ (оператор !) ќе биде спротивното од операндот, односно точно ако операндот има вредност неточно, и неточно ако операндот има вредност точно.</para>
          <para id="import-auto-id1172364314854">При тоа треба да се води сметка дека резултатот на секој релационен логички израз во С е 0 за неточно или 1 за точно ( и покрај тоа што секоја ненулева вредност ја третира како точно).</para>
          <code id="eip-973" display="block">i = 5; j = 0; k = -1;
s = i &amp;&amp; k || j; // s = 1</code><para id="import-auto-id1172364779052">поради истиот приоритет прво се изведува И операцијата, а потоа ИЛИ.</para>
          <example id="eip-397"><code id="eip-585" display="block"># include &lt;stdio.h&gt;
main()
{
    float f = 5.5;
    int i = 7;
    char c = ‘w’;

    printf("%d\t",(i&gt;=6)&amp;&amp;(c=='w')); // 1
    printf("%d\t",(i&gt;=6)&amp;&amp;(c==119)); // 1
    printf("%d\t",(f&lt;11)&amp;&amp;(i&gt;100));  // 0
    printf("%d\n",(c != 'p')||((i+f)&lt;=10)); // 1
    // !!! da se upotrebuvaat zagradi
    printf("%d %d\n",(!i == 7), (!(i == 7))); // 0 0 
    // da vnimava da ne se koristi = namesto ==
    printf("%d %d\n",(!i == 0), (!(i = 0)));  // 0 1
}</code></example><para id="import-auto-id1172362990279">Треба да се води сметка дека извршувањето на релационите логички изрази е од лево на десно и дека истата не се изведува докрај доколку нема потреба за тоа.</para></section>
        <section id="import-auto-id1172364716046">
          <title>Оператор за доделување (=)</title>
          <para id="import-auto-id1172355170489">Доделувањето на вредност се врши со помош на = операторот. При тоа вредноста од левата страна на = се доделува на променливата од десната страна на =. Употребата на овој оператор е многу флексибилна. Доделената вредност е секогаш достапна за повторна употреба при доделување и при тоа операцијата се изведува секогаш од десно на лево, а има низок приоритет:</para>
          <code id="eip-622" display="block">int i, j, k, l, m, n;
i = j = k = l = m = n = 22;
printf(”%i\n”, j=93);</code></section>
      </section>
    </section>
  </content>
</document>